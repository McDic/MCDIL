// ----------------------------------------------------------------------------
// Imports

%import common.ESCAPED_STRING   -> STRING
%import common.SIGNED_INT       -> INT32
%import common.SIGNED_FLOAT     -> FLOAT
%import common.CNAME            -> IDENTIFIER
%import common.CPP_COMMENT
%import common.C_COMMENT

%import common.WS
%ignore WS

// ----------------------------------------------------------------------------
// Primitives

?comment: CPP_COMMENT | C_COMMENT

namespaced_identifier:    IDENTIFIER ( "::" IDENTIFIER )*
                        | "this"

literal:  INT32         -> int32
        | FLOAT         -> float
        | "true"        -> true
        | "false"       -> false
        | STRING        -> string
        | selector_literal

?type_qualifier:  "immutable"   -> immutable
                | "static"      -> static

?primitive_type:  "int"         -> int32_type
                | "bool"        -> bool_type
                | "null"        -> null_type
                | "float"       -> float_type
                | "string"      -> string_type

?builtin_type:    primitive_type
                | "auto"        -> auto_type
                | "deque"       -> deque_type
                | "selector"    -> selector_type
                | "D3"          -> location_type
                | "R2"          -> rotation_type

any_type_without_dimension: (builtin_type | namespaced_identifier) templated_type_suffix?

any_type: any_type_without_dimension ("[" INT32 "]")*

qualified_type: type_qualifier? any_type

public_qualifier: "export"

// ----------------------------------------------------------------------------
// Minecraft Specific Terms

single_coordinate: ("~" | "^")? (namespaced_identifier | INT32 | FLOAT)

location: "3D" "(" single_coordinate "," single_coordinate "," single_coordinate ","? ")"

rotation: "2R" "(" single_coordinate "," single_coordinate ","? ")"

selector_literal: /\@[parse]/

// ----------------------------------------------------------------------------
// Common Statements

program: code_unit+

code_unit: (statement ";") | comment

?statement: simple_statement | command_statement | compound_statement

?simple_statement:    initialization
                    | assignable_statement
                    | sleep_statement
                    | escape_statement
                    | import_statement
                    | deactivate_statement

?compound_statement:  function_definition
                    | while_loop
                    | execute_loop
                    | branch
                    | namespace
                    | struct_definition

// ----------------------------------------------------------------------------
// Simple Statements

variable_definition: public_qualifier? qualified_type IDENTIFIER

initialization:   variable_definition "=" assignable_statement                          -> init_with_alter
                | variable_definition "(" parameter_pass ("," parameter_pass)* ","? ")" -> init_with_ctor

assignable_statement?:    namespaced_identifier alter_operator assignable_statement                                         -> alter_statement
                        | namespaced_identifier "><" namespaced_identifier                                                  -> swap_statement
                        | "(" assignable_statement ("," assignable_statement)* ","? ")"                                     -> tuple_statement
                        | assignable_statement "[" assignable_statement ("," assignable_statement)* "]"                     -> indexing_statement
                        | namespaced_identifier
                        | literal
                        | call_statement
                        | "(" assignable_statement ")" "?" "(" assignable_statement ")" ":" "(" assignable_statement ")"    -> ternary_statement
                        | unary_operator assignable_statement                                                               -> unary_statement
                        | assignable_statement binary_operator assignable_statement                                         -> binary_statement

parameter_pass: IDENTIFIER "=" assignable_statement

call_statement: (namespaced_identifier | any_type_without_dimension) "(" parameter_pass ("," parameter_pass)* ")"

?unary_operator:          "+"   -> op_pos
                        | "-"   -> op_neg

?binary_operator:     "+"   -> op_add
                    | "-"   -> op_sub
                    | "*"   -> op_mul
                    | "/"   -> op_div
                    | "%"   -> op_mod
                    | "=="  -> op_eq
                    | "!="  -> op_ne
                    | "<"   -> op_lt
                    | "<="  -> op_le
                    | ">"   -> op_gt
                    | ">="  -> op_ge

sleep_statement: "sleep" "(" FLOAT ")"

?alter_operator:  "="   -> assign_op
                | "+="  -> assign_op_add
                | "-="  -> assign_op_sub
                | "*="  -> assign_op_mul
                | "/="  -> assign_op_div
                | "%="  -> assign_op_mod

escape_statement:     "return" assignable_statement     -> return_statement
                    | "continue"                        -> continue_statement
                    | "break"                           -> break_statement

import_statement: "from" STRING "import" ( (namespaced_identifier ("," namespaced_identifier)* ","?) | "*")

deactivate_statement: "deactivate" IDENTIFIER

// ----------------------------------------------------------------------------
// Direct Commands

?command_statement: raw_command | teleport_command

raw_command: "raw" STRING

teleport_command: "tp" "(" (namespaced_identifier | selector_literal) "," assignable_statement "," assignable_statement "," assignable_statement ","? ")"

// ----------------------------------------------------------------------------
// Basic Compound Statements

general_block: "{" code_unit* "}"

function_parameters: variable_definition ("," variable_definition)* ","?

function_definition: public_qualifier? ("ticking" | template_definition)? "function" IDENTIFIER "(" function_parameters ")" "->" any_type general_block

while_loop: "while" "(" assignable_statement ")" general_block

if_block: "if" "(" assignable_statement ")" general_block

else_block: "else" general_block

branch: if_block ("else" if_block)* else_block?

namespace: public_qualifier? "namespace" namespaced_identifier general_block

// ----------------------------------------------------------------------------
// Execute

execute_condition:        "as" (namespaced_identifier | selector_literal)                                               -> execute_condition_as
                        | "at" (namespaced_identifier | selector_literal)                                               -> execute_condition_at
                        | "facing" (namespaced_identifier | selector_literal | location)                                -> execute_condition_facing
                        | "in" STRING                                                                                   -> execute_condition_dimension
                        | "on" ("attacker" | "controller" | "leasher" | "origin" | "passengers" | "target" | "vehicle") -> execute_condition_on
                        | "positioned" (namespaced_identifier | selector_literal | location)                            -> execute_condition_positioned
                        | "rotated" (namespaced_identifier | selector_literal | rotation)                               -> execute_condition_rotated

execute_loop: "execute" "(" execute_condition (";" execute_condition)* ";"? ")" general_block

// ----------------------------------------------------------------------------
// Struct

struct_initializer: "init" "(" function_parameters ")" (general_block | ":" IDENTIFIER "(" parameter_pass ("," parameter_pass)* ","? ")")

struct_inheritance: ":" namespaced_identifier ("," namespaced_identifier)*

struct_definition: public_qualifier? template_definition? "struct" IDENTIFIER struct_inheritance? "{" (variable_definition ";")* (struct_initializer ";")* (function_definition ";")* "}"

// ----------------------------------------------------------------------------
// Generic

template_definition_arg: ("typename" | primitive_type) IDENTIFIER

template_definition: "template" "<" template_definition_arg ("," template_definition_arg)* ","? ">"

template_arg: any_type | assignable_statement

templated_type_suffix: "<" template_arg ("," template_arg)* ","? ">"
